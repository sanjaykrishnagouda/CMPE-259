head	1.7;
access;
symbols;
locks
	kerryveenstra:1.7; strict;
comment	@// @;


1.7
date	2014.08.03.04.23.17;	author kerryveenstra;	state Exp;
branches;
next	1.6;

1.6
date	2013.07.21.03.46.20;	author kerryveenstra;	state Exp;
branches;
next	1.5;

1.5
date	2013.07.14.01.53.55;	author kerryveenstra;	state Exp;
branches;
next	1.4;

1.4
date	2013.03.28.17.05.17;	author kerryveenstra;	state Exp;
branches;
next	1.3;

1.3
date	2013.02.24.08.34.20;	author kerryveenstra;	state Exp;
branches;
next	1.2;

1.2
date	2013.02.19.08.58.39;	author kerryveenstra;	state Exp;
branches;
next	1.1;

1.1
date	2013.02.18.02.32.20;	author kerryveenstra;	state Exp;
branches;
next	;


desc
@simulated annealing algorithms
@


1.7
log
@added viewpoint_height_above_terrain
@
text
@/******************************************************************************

File:       sa.cpp
Purpose:    Simulated Annealing algorithm
Author:     Kerry Veenstra

-------------------
Simulated Annealing
-------------------

We use the Simulated Annealing Algorithm as described in Chapter 2 of Sait
and Youssef [1].  We follow the algorithm listing on p. 54 directly, except
for the cooling schedule.  Instead of using the simple cooling schedule, we
use the dynamic temperature and Markov-chain length adjuster from Section
2.4.3.


----------------
Cooling Schedule
----------------

We use the cooling schedule by Huang, Romeo, and Sangiovanni-Vincentelli
[2].  This schedule  ensures that the simulated-annealing algorithm's
execution time is reasonable.  Its operation is described below:

1.  Set T based on the standard deviation of the cost function, sigma.  The
    idea is to set T so that the system is 90% likely to accept a
    configuration that is 3 sigma worse.

    prob_of_accepting_three_sigma_worse_cost = 0.9
    k = -3 / ln(prob_of_accepting_three_sigma_worse_cost)
    T = k * sigma

2.  At each step, decrease T such that the cost decreases by an amount that
    is less than the cost's standard deviation. Sait and Youssef [1]
    justify the equation below. The value of lambda * sigma is the target
    reduction in cost.

    lambda = 0.7
    T = T * exp(-lambda * T / sigma)

3.  At some point, . . . (check reference).


----------
References
----------

[1] Sait and Youssef. Iterative Computer Algorithms with Applications in
    Engineering: Solving Combinatorial Optimization Problems. ISBN
    0-7695-0100-1.

[2] Huang, Romeo, and Sangiovanni-Vincentelli.  "An Efficient General
    Cooling Schedule for Simulated Annealing," IEEE Trans.  Comp. Aided
    Des.  pp. 381-384. 1986.

******************************************************************************/

#include <limits>
#include <vector>

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

extern "C"
{
#include "srtm.h"
#include "cvis_wang.h"
#include "bmp.h"
#include "visibility.h"
}

#include "ge.h"
#include "Disk.h"
#include "State.h"
#include "Statistics.h"
#include "Temperature.h"
#include "Agent.h"

extern "C"
{
#include "sa.h"
}


// Merge agents' states with other agents that are in
// communication range.  We're going to use a simple
// O(n^2) algorithm.

// Agent x stores its own state in the x'th position
// of its state vector.  We copy this information to the
// x'th position of other agents that are in communication
// range.
void sa_communicate_locations
(
    std::vector<Agent> &agents,
    int                 communication_radius_max
)
{
    int a_index = 0;

    for (auto &a : agents)
    {
        int b_index = 0;

        for (auto &b : agents)
        {
            if (a_index != b_index)
            {
                printf("%2d %2d :", a_index, b_index);

                // Is agent b close to agent a?
                double di = b.S.pi[b_index] - a.S.pi[a_index];
                double dj = b.S.pj[b_index] - a.S.pj[a_index];
                int distance = (int) sqrt(di * di + dj * dj);

                if (distance > communication_radius_max)
                {
                    b.S.pcommunicating[a_index] = false;
                }
                else
                {
                    b.S.pcommunicating[a_index] = true;

                    // Copy agent a's position to agent b.
                    printf(" copy position");
                    b.S.pi[a_index] = a.S.pi[a_index];
                    b.S.pj[a_index] = a.S.pj[a_index];
                }

                printf("\n");
            }

            ++b_index;
        }

        ++a_index;
    }
}


//  Function:       sa_metropolis_loop
//
//  Description:    Inner loop of a Simulated Annealing algorithm.
//
//                  Given references to the system's current and best
//                  states, anneal at temperature T for M times.
//
//                  From p. 54 of Sait and Youssef's book "Iterative
//                  Computer Algorithms with Applications in Engineering:
//                  Solving Combinatorial Optimization Problems", ISBN
//                  0-7695-0100-1.
//
Statistics sa_metropolis_loop
(
    State  &S,
    int    &utility,
    State  &S_best,
    int    &utility_best,
    double  T,
    int     M,
    int     sensor_radius_max,
    int     viewpoint_height_above_terrain,
    int     jump_radius_max,
    int     exploration_radius_max,
    bool    use_distributed_algorithm = false,
    int     forced_k                  = 0       // if using dist. algo.
)
{
    Disk        exploration_region;
    int         k;
    Statistics  stats_utility;

    if (use_distributed_algorithm)
    {
        // Select specified agent.
        k                   = forced_k;
        exploration_region  = Disk(S.pi[k], S.pj[k], exploration_radius_max);
    }
    else
    {
        // Select random agent.
        k                   = ge_rand_uniform_int(0, S.num_viewpoints - 1);
        exploration_region  = Disk(0, 0, INFINITE_RADIUS);
    }

    do
    {
        // Generate a state and check its utility.
        State S_new = sa_rand_next_state(S,
                                         sensor_radius_max,
                                         jump_radius_max,
                                         exploration_region,
                                         v,
                                         use_distributed_algorithm,
                                         k);

        int utility_new     = cvis_wang_malloc_count(&v, &z, srtm,
                                 S_new.num_viewpoints,
                                 S_new.pi, S_new.pj, S_new.pcommunicating,
                                 sensor_radius_max,
                                 viewpoint_height_above_terrain);

        int delta_utility   = utility_new - utility;

        if (delta_utility > 0 ||
            (
             T > 0.0 &&
             ge_rand_uniform_double(0.0, 1.0) < exp(delta_utility / T)
            )
           )
        {
            //printf("accept delta_utility %7d utility %7d T %5.0f M %5d k %2d\n",
            //       delta_utility, utility_new, T, M, k);

            S       = S_new;
            utility = utility_new;
        }

        stats_utility.summation(utility);
        
        if (utility_new > utility_best)
        {
            S_best       = S_new;
            utility_best = utility_new;
        }

        M = M - 1;
    } while (M > 0);

    return stats_utility;
}


/**************************************************************************
Purpose:    Evolve the positions of several viewpoints by simulated
            annealing.  Use a utility function that tends to maximize the
            total number of map pixels that are visible to any of the
            viewpoints.

            Simulate a centralized algorithm:  Optimize the locations of
            all viewpoints.  This approach is closest to classic simulated
            annealing.  It should give the best results.

            Original algorithm from p. 54 of Sait and Youssef's book
            "Iterative Computer Algorithms with Applications in
            Engineering: Solving Combinatorial Optimization Problems", ISBN
            0-7695-0100-1.

Returns:    Utility of final configuration.
**************************************************************************/
int sa_simulated_annealing_centralized
(
    int     temp_initial,
    State  &S,                          // initial state (initial viewpoints)
    int     sensor_radius_max,
    int     viewpoint_height_above_terrain,
    int     jump_radius_max,
    int     exploration_radius_max,
    int     communication_radius_max,
    double  alpha,
    double  beta,
    double  lambda,
    int     M_initial,
    int     time_max,
    bool    use_distributed_algorithm
)
{
    const int k = 20;   // Recommended value from reference.

    printf("temp_initial = %d\n", temp_initial);
    printf("sensor_radius_max = %d\n", sensor_radius_max);
    printf("jump_radius_max = %d\n", jump_radius_max);
    printf("exploration_radius_max = %d\n", exploration_radius_max);
    printf("alpha = %f\n", alpha);
    printf("beta = %f\n", beta);
    printf("M_initial = %d\n", M_initial);
    printf("time_max = %d\n", time_max);

    // Initialize v and compute utility.
    int utility = cvis_wang_malloc_count(&v, &z, srtm,
                      S.num_viewpoints, S.pi, S.pj, S.pcommunicating,
                      sensor_radius_max,
                      viewpoint_height_above_terrain);

    printf("utility = %d\n", utility);

    // The simulated-annealing loop:
    State   S_best              = S;
    int     utility_best        = utility;
    int     time                = 0;
    double  num_cycles_at_temp  = M_initial;

    // Determine an initial temperature that is based on sigma.

    Temperature T(INFINITE_TEMPERATURE);   // Accept all generated states.

    Statistics stats_utility =
        sa_metropolis_loop(S, utility, S_best, utility_best,
                           T.current(), (int) num_cycles_at_temp,
                           sensor_radius_max, viewpoint_height_above_terrain,
                           jump_radius_max,
                           exploration_radius_max);

    T = Temperature(k * stats_utility.standard_deviation());


    // Now anneal.

    do
    {
        stats_utility = sa_metropolis_loop(S, utility, S_best, utility_best,
                           T.current(), (int) num_cycles_at_temp,
                           sensor_radius_max, viewpoint_height_above_terrain,
                           jump_radius_max,
                           exploration_radius_max);

        time                += num_cycles_at_temp;
        num_cycles_at_temp  *= beta;

        if (T.current() == 0.0) break;

        T.next_huang(lambda, stats_utility);
    } while (time < time_max);

    S = S_best;

    // Oops.  We've been saving the best S seen, but we've not been
    // maintaining the best v.  Restore v to match the best S.
    utility = cvis_wang_malloc_count(&v, &z, srtm,
                   S.num_viewpoints, S.pi, S.pj, S.pcommunicating,
                   sensor_radius_max, viewpoint_height_above_terrain);

    return utility;
}


/**************************************************************************
Purpose:    Evolve the positions of several viewpoints by simulated
            annealing.  Use a utility function that tends to maximize the
            total number of map pixels that are visible to any of the
            viewpoints.

            Emulate a distributed algorithm:  Each node optimizes its own
            state individually, assuming that all other nodes are
            stationary.  However if the node can communicate with any
            nearby nodes, then it will consider the states of those nodes
            (their simulated locations) after each Metropolis loop.  The
            nature of internode communication is limited to the node's
            portion of its state vector.  Each node computes its own
            annealing schedule.

            Original algorithm from p. 54 of Sait and Youssef's book
            "Iterative Computer Algorithms with Applications in
            Engineering: Solving Combinatorial Optimization Problems", ISBN
            0-7695-0100-1.

Returns:    Utility of final configuration.
**************************************************************************/
int sa_simulated_annealing_distributed
(
    int     temp_initial,
    State  &S,                          // initial state (initial viewpoints)
    int     sensor_radius_max,
    int     viewpoint_height_above_terrain,
    int     jump_radius_max,
    int     exploration_radius_max,
    int     communication_radius_max,
    double  alpha,
    double  beta,
    double  lambda,
    int     M_initial,
    int     time_max,
    bool    use_distributed_algorithm
)
{
    const int k = 20;   // Recommended value from reference.

    printf("temp_initial = %d\n", temp_initial);
    printf("sensor_radius_max = %d\n", sensor_radius_max);
    printf("jump_radius_max = %d\n", jump_radius_max);
    printf("exploration_radius_max = %d\n", exploration_radius_max);
    printf("alpha = %f\n", alpha);
    printf("beta = %f\n", beta);
    printf("M_initial = %d\n", M_initial);
    printf("time_max = %d\n", time_max);

    int utility;
    int utility_best;

    int time = 0;


    // Create an agent for each viewpoint.
    std::vector<Agent> agents;

    for (int i = 0; i < S.num_viewpoints; ++i)
    {
        agents.push_back(Agent(S, INFINITE_TEMPERATURE));
    }

    sa_communicate_locations(agents, communication_radius_max);


    // For each agent, determine an initial temperature that is based
    // on sigma.
    int a_index = 0;

    for (auto &a : agents)
    {
        utility = cvis_wang_malloc_count(&v, &z, srtm,
                          a.S.num_viewpoints, a.S.pi, a.S.pj,
                          a.S.pcommunicating,
                          sensor_radius_max,
                          viewpoint_height_above_terrain);

        printf("agent = %d, utility = %d\n", a_index, utility);

        a.S_best              = a.S;
        a.utility_best        = utility;
        a.num_cycles_at_temp  = M_initial;

        // Accept all generated states.
        a.T = Temperature(INFINITE_TEMPERATURE);

        a.stats_utility =
            sa_metropolis_loop(a.S,
                               utility,
                               a.S_best,
                               a.utility_best,
                               a.T.current(),
                               (int) a.num_cycles_at_temp,
                               sensor_radius_max,
                               viewpoint_height_above_terrain,
                               jump_radius_max,
                               exploration_radius_max,
                               true,    // use_distributed_algorithm
                               a_index);

        // Compute an initial temperature.
        a.T = Temperature(k * a.stats_utility.standard_deviation());

        ++a_index;
    }


    //
    // Now anneal.
    //

    do
    {
        // Anneal each agent for *one* Metropolis loop.
        a_index = 0;

        for (auto &a : agents)
        {
            a.stats_utility = sa_metropolis_loop(a.S,
                                  utility,
                                  a.S_best,
                                  a.utility_best,
                                  a.T.current(),
                                  (int) a.num_cycles_at_temp,
                                  sensor_radius_max,
                                  viewpoint_height_above_terrain,
                                  jump_radius_max,
                                  exploration_radius_max,
                                  true,    // use_distributed_algorithm
                                  a_index);

            a.time                  += a.num_cycles_at_temp;
            a.num_cycles_at_temp    *= beta;

            ++a_index;
        }


        // Agents have moved.
        sa_communicate_locations(agents, communication_radius_max);


        // Merge all of the agents' S's into S.
        a_index = 0;

        for (auto &a : agents)
        {
            S.pi[a_index] = a.S.pi[a_index];
            S.pj[a_index] = a.S.pj[a_index];

            ++a_index;
        }


        // Compute the utility of the merged state.
        utility_best = cvis_wang_malloc_count(&v, &z, srtm,
                            S.num_viewpoints, S.pi, S.pj, S.pcommunicating,
                            sensor_radius_max,
                            viewpoint_height_above_terrain);


        // Terminate loop if all agents are frozen.
        bool all_agents_are_frozen = true;

        for (auto &a : agents)
        {
            if (a.T.current() > 0.0) all_agents_are_frozen = false;
        }

        if (all_agents_are_frozen) break;


        // Compute agents' next temperatures and advance global time.
        for (auto &a : agents)
        {
            a.T.next_huang(lambda, a.stats_utility);

            if (time < a.time)
            {
                time = a.time;
            }
        }

    } while (time < time_max);

    return utility_best;
}

/**************************************************************************
Purpose:    Evolve the positions of several viewpoints by simulated
            annealing.  Use a utility function that tends to maximize the
            total number of map pixels that are visible to any of the
            viewpoints.

            You can direct this algorithm to proceed in either of two ways.

            (1) Emulate a centralized algorithm:  Optimize the locations of
                all viewpoints.  This approach is closest to classic
                simulated annealing.  It should give the best results.

            (2) Emulate a distributed algorithm:  Each node optimizes
                its own state individually, assuming that all other nodes
                are stationary.  However if the node can communicate with
                any nearby nodes, then it will consider the states of those
                nodes (their simulated locations) after each Metropolis
                loop.  The nature of internode communication is limited to
                the node's portion of its state vector.  Each node computes
                its own annealing schedule.

            Original algorithm from p. 54 of Sait and Youssef's book
            "Iterative Computer Algorithms with Applications in
            Engineering: Solving Combinatorial Optimization Problems", ISBN
            0-7695-0100-1.

Returns:    Utility of final configuration.
**************************************************************************/
extern "C" int sa_simulated_annealing
(
    int     temp_initial,
    State  &S,                          // initial state (initial viewpoints)
    int     sensor_radius_max,
    int     viewpoint_height_above_terrain,
    int     jump_radius_max,
    int     exploration_radius_max,
    int     communication_radius_max,
    double  alpha,
    double  beta,
    double  lambda,
    int     M_initial,
    int     time_max,
    bool    use_distributed_algorithm,
    const char *bmp_sequence_basename
)
{
    if (use_distributed_algorithm)
    {
        return sa_simulated_annealing_distributed
        (
            temp_initial, S, sensor_radius_max,
            viewpoint_height_above_terrain, jump_radius_max,
            exploration_radius_max, communication_radius_max,
            alpha, beta, lambda, M_initial, time_max,
            use_distributed_algorithm
        );
    }
    else
    {
        return sa_simulated_annealing_centralized
        (
            temp_initial, S, sensor_radius_max,
            viewpoint_height_above_terrain, jump_radius_max,
            exploration_radius_max, communication_radius_max,
            alpha, beta, lambda, M_initial, time_max,
            use_distributed_algorithm
        );
    }
}

@


1.6
log
@honor exporation radius during melting
@
text
@d164 1
d202 2
a203 1
                                 sensor_radius_max);
d214 2
a215 2
            printf("accept delta_utility %7d utility %7d T %5.0f M %5d k %2d\n",
                   delta_utility, utility_new, T, M, k);
d258 1
d284 2
a285 1
                      sensor_radius_max);
d302 2
a303 1
                           sensor_radius_max, jump_radius_max,
d315 2
a316 1
                           sensor_radius_max, jump_radius_max,
d329 7
a335 1
    return utility_best;
d366 1
d415 2
a416 1
                          sensor_radius_max);
d435 1
d466 1
d498 2
a499 1
                            sensor_radius_max);
d562 1
d571 2
a572 1
    bool    use_distributed_algorithm
d579 2
a580 1
            temp_initial, S, sensor_radius_max, jump_radius_max,
d590 2
a591 1
            temp_initial, S, sensor_radius_max, jump_radius_max,
@


1.5
log
@simulate distributed algorithm
@
text
@d422 1
a422 1
                               INFINITE_RADIUS,  // exploration_radius_max
a577 233


#if 0
/**************************************************************************
Purpose:    Evolve the positions of several viewpoints by simulated
            annealing.  Use a utility function that tends to maximize the
            total number of map pixels that are visible to any of the
            viewpoints.

            You can direct this algorithm to proceed in either of two ways.

            (1) Emulate a centralized algorithm:  Optimize the locations of
                all viewpoints.  This approach is closest to classic
                simulated annealing.  It should give the best results.

            (2) Emulate a distributed algorithm:  Each node optimizes
                its own state individually, assuming that all other nodes
                are stationary.  However if the node can communicate with
                any nearby nodes, then it will consider the states of those
                nodes (their simulated locations) after each Metropolis
                loop.  The nature of internode communication is limited to
                the node's portion of its state vector.  Each node computes
                its own annealing schedule.

            Original algorithm from p. 54 of Sait and Youssef's book
            "Iterative Computer Algorithms with Applications in
            Engineering: Solving Combinatorial Optimization Problems", ISBN
            0-7695-0100-1.

Returns:    Utility of final configuration.
**************************************************************************/
extern "C" int sa_simulated_annealing
(
    int     temp_initial,
    State  &S,                          // initial state (initial viewpoints)
    int     sensor_radius_max,
    int     jump_radius_max,
    int     exploration_radius_max,
    int     communication_radius_max,
    double  alpha,
    double  beta,
    double  lambda,
    int     M_initial,
    int     time_max,
    bool    use_distributed_algorithm
)
{
    const int k = 20;   // Recommended value from reference.

    printf("temp_initial = %d\n", temp_initial);
    printf("sensor_radius_max = %d\n", sensor_radius_max);
    printf("jump_radius_max = %d\n", jump_radius_max);
    printf("exploration_radius_max = %d\n", exploration_radius_max);
    printf("alpha = %f\n", alpha);
    printf("beta = %f\n", beta);
    printf("M_initial = %d\n", M_initial);
    printf("time_max = %d\n", time_max);

    // Initialize v and compute utility.
    int utility = cvis_wang_malloc_count(&v, &z, srtm,
                      S.num_viewpoints, S.pi, S.pj, S.pcommunicating,
                      sensor_radius_max);

    printf("utility = %d\n", utility);

    // The simulated-annealing loop:
    State   S_best              = S;
    int     utility_best        = utility;
    int     time                = 0;
    double  num_cycles_at_temp  = M_initial;

    if (use_distributed_algorithm)
    {
        // Create an agent for each viewpoint.
        std::vector<Agent> agents;

        for (int i = 0; i < S.num_viewpoints; ++i)
        {
            agents.push_back(Agent(S, INFINITE_TEMPERATURE));
        }

        sa_communicate_locations(agents, communication_radius_max);


        // For each agent, determine an initial temperature that is based
        // on sigma.
        int a_index = 0;

        for (auto &a : agents)
        {
            a.S_best              = a.S;
            a.utility_best        = utility;
            a.time                = 0;
            a.num_cycles_at_temp  = M_initial;

            a.T = Temperature(INFINITE_TEMPERATURE);   // Accept all generated states.

            a.stats_utility =
                sa_metropolis_loop(a.S,
                                   utility,
                                   a.S_best,
                                   a.utility_best,
                                   a.T.current(),
                                   (int) a.num_cycles_at_temp,
                                   sensor_radius_max,
                                   jump_radius_max,
                                   INFINITE_RADIUS,  // exploration_radius_max
                                   true,    // use_distributed_algorithm
                                   a_index);

            // Compute an initial temperature.
            a.T = Temperature(k * a.stats_utility.standard_deviation());

            ++a_index;
        }


        //
        // Now anneal.
        //

        do
        {
            // Anneal each agent during one Metropolis loop.
            a_index = 0;

            for (auto &a : agents)
            {
                a.stats_utility = sa_metropolis_loop(a.S,
                                      utility,
                                      a.S_best,
                                      a.utility_best,
                                      a.T.current(),
                                      (int) a.num_cycles_at_temp,
                                      sensor_radius_max,
                                      jump_radius_max,
                                      exploration_radius_max,
                                      true,    // use_distributed_algorithm
                                      a_index);

                a.time                  += a.num_cycles_at_temp;
                a.num_cycles_at_temp    *= beta;

                ++a_index;
            }


            // Only agents in communication range know of each other's
            // locations.
            sa_communicate_locations(agents, communication_radius_max);


            // Merge all of the agents' S's into S.
            a_index = 0;

            for (auto &a : agents)
            {
                S.pi[a_index] = a.S.pi[a_index];
                S.pj[a_index] = a.S.pj[a_index];

                ++a_index;
            }


            // Compute the utility of the merged state.
            utility_best = cvis_wang_malloc_count(&v, &z, srtm,
                             S.num_viewpoints, S.pi, S.pj, S.pcommunicating,
                             sensor_radius_max);


            // Terminate loop if all agents are frozen.
            bool all_agents_are_frozen = true;

            for (auto &a : agents)
            {
                if (a.T.current() > 0.0) all_agents_are_frozen = false;
            }

            if (all_agents_are_frozen) break;


            // Compute agents' next temperatures and advance global time.
            for (auto &a : agents)
            {
                a.T.next_huang(lambda, a.stats_utility);

                if (time < a.time)
                {
                    time = a.time;
                }
            }

        } while (time < time_max);
    }
    else
    {
        // Determine an initial temperature that is based on sigma.

        Temperature T(INFINITE_TEMPERATURE);   // Accept all generated states.

        Statistics stats_utility =
            sa_metropolis_loop(S, utility, S_best, utility_best,
                               T.current(), (int) num_cycles_at_temp,
                               sensor_radius_max, jump_radius_max,
                               exploration_radius_max);

        // Compute an initial temperature.
        T = Temperature(k * stats_utility.standard_deviation());


        // Now anneal.

        do
        {
            stats_utility = sa_metropolis_loop(S, utility, S_best, utility_best,
                               T.current(), (int) num_cycles_at_temp,
                               sensor_radius_max, jump_radius_max,
                               exploration_radius_max);

            time                += num_cycles_at_temp;
            num_cycles_at_temp  *= beta;

            if (T.current() == 0.0) break;

            T.next_huang(lambda, stats_utility);
        } while (time < time_max);

        S = S_best;
    }

    return utility_best;
}
#endif
@


1.4
log
@added support for distributed algorithm
@
text
@d87 56
d166 2
a167 1
    bool    use_distributed_algorithm = false
d170 2
d174 12
a185 1
    int k = (int) (ge_rand_double() * S.num_viewpoints);
d189 1
d193 1
a193 2
                                         Disk(0, 0, 999999),  // No limit when
                                                              // centralized.
d195 2
a196 2
                                         k,
                                         use_distributed_algorithm);
d198 4
a201 4
        cvis_wang_malloc(&v, &z, srtm,
                         S_new.num_viewpoints,
                         S_new.pi, S_new.pj,
                         sensor_radius_max);
a202 1
        int utility_new     = cvis_wang_count(&v);
d206 5
a210 1
            (T > 0.0 && ge_rand_double() < exp(delta_utility / T)))
d212 2
a213 2
            printf("accept delta_utility %7d utility %7d T %5.0f M %5d\n",
                   delta_utility, utility_new, T, M);
d240 347
d637 3
a639 5
    cvis_wang_malloc(&v, &z, srtm,
                     S.num_viewpoints, S.pi, S.pj,
                     sensor_radius_max);

    int utility = cvis_wang_count(&v);
d651 2
a652 1
        std::vector<Agent> agent;
a653 5
        // If we are using a distributed algorithm, then each viewpoint stores
        // its own state.
        //
        // Start with an "infinite" temperature.
        //
d656 1
a656 1
            agent.push_back(Agent(S, 999999));
d659 8
a666 2
        // Determine an initial temperature that is based on sigma.
        for (auto &a : agent)
d668 1
a668 1
            a.S_best              = S;
d673 1
a673 1
            a.T = Temperature(999999);   // Accept all generated states.
d676 11
a686 6
                sa_metropolis_loop(a.S, utility, a.S_best, a.utility_best,
                                   a.T.current(), (int) a.num_cycles_at_temp,
                                   sensor_radius_max, jump_radius_max,
                                   exploration_radius_max,
                                   true // use_distributed_algorithm
                                   );
d690 2
d695 1
d697 1
d702 3
a704 1
            for (auto &a : agent)
d706 3
a708 1
                a.stats_utility = sa_metropolis_loop(a.S, utility, a.S_best,
d710 4
a713 2
                                      a.T.current(), (int) a.num_cycles_at_temp,
                                      sensor_radius_max, jump_radius_max,
d715 2
a716 2
                                      true // use_distributed_algorithm
                                      );
d720 2
d725 7
a731 4
            // Merge agents' states with other agents that are in
            // communication range.  We're going to use a simple
            // O(n^2) algorithm that skips degenerate pairs.
            int ai = 0;
d733 1
a733 1
            for (auto &a : agent)
d735 2
a736 1
                int bi = 0;
d738 2
a739 23
                for (auto &b : agent)
                {
                    if (ai != bi)
                    {
                        // Is agent b close to agent a?
                        long distance_squared =
                            (b.S.pi[bi] - a.S.pi[ai]) *
                            (b.S.pi[bi] - a.S.pi[ai]) +
                            (b.S.pj[bi] - a.S.pj[ai]) *
                            (b.S.pj[bi] - a.S.pj[ai]);

                        int distance = (int) sqrt((double) distance_squared);

                        if (distance <= communication_radius_max)
                        {
                            // Copy agent a's position to agent b.
                            b.S.pi[ai] = a.S.pi[ai];
                            b.S.pj[ai] = a.S.pj[ai];
                        }
                    }

                    ++bi;
                }
d742 4
a745 2
                ++ai;
            }
d748 1
a748 1
            // Loop is done when all agents are frozen.
d751 1
a751 1
            for (auto &a : agent)
d759 2
a760 2
            // Next temperature
            for (auto &a : agent)
d763 5
d769 1
a770 2

        S = S_best;
d776 1
a776 1
        Temperature T(999999);   // Accept all generated states.
d782 1
a782 2
                               exploration_radius_max,
                               use_distributed_algorithm);
d795 1
a795 2
                               exploration_radius_max,
                               use_distributed_algorithm);
d810 1
a810 1

@


1.3
log
@moved sa_rand_double() to ge_rand_double()
@
text
@d11 5
a15 4
We use the Simulated Annealing Algorithm as described in Chapter 2 of
[Ref 1].  We follow the algorithm listing on p. 54 directly, except for the
cooling schedule.  Instead of the simple cooling schedule, we use the
dynamic temperature and Markov-chain length adjuster from Section 2.4.3.
d22 3
a24 4
To ensure that the algorithm's execution time is reasonable, we use one of
the cooling schedules presented in Sait and Youssef. This one is by Huang,
Romeo, and Sangiovanni-Vincentelli: "An Efficient General Cooling Schedule
for Simulated Annealing." IEEE Trans. Comp. Aided Des. pp. 381-384. 1986.
d27 2
a28 2
    idea is to set T so that the system is likely to accept a configuration
    that is 3 sigma worse.
d35 3
a37 3
    is less than the cost's standard deviation. Sait and Youssef justify
    the equation below. The value of lambda * sigma is the target reduction
    in cost.
d49 7
a55 3
[Ref 1] Sait and Youssef. Iterative Computer Algorithms with Applications
        in Engineering: Solving Combinatorial Optimization Problems. ISBN
        0-7695-0100-1.
d60 1
d75 1
d79 1
d107 4
a110 2
    int     visibility_radius_max,
    int     dist_max
d115 2
d119 8
a126 1
        State S_new = sa_rand_next_state(S, visibility_radius_max, dist_max, v);
d131 1
a131 1
                         visibility_radius_max);
d139 1
a139 1
            printf("accept delta_utility=%d, utility=%d, T=%f, M=%d\n",
d161 28
a188 10
/*
 *  Purpose:    Evolve the positions of several viewpoints by simulated
 *              annealing.  Use a utility function that tends to maximize
 *              the total number of map locations that are visible to any
 *              of the viewpoints.
 *
 *  ...
 *
 *  Returns:    Utility of final configuration.
 */
d193 4
a196 2
    int     visibility_radius_max,
    int     dist_max,
d201 2
a202 1
    int     time_max
d208 3
a210 2
    printf("visibility_radius_max = %d\n", visibility_radius_max);
    printf("dist_max = %d\n", dist_max);
d219 1
a219 1
                     visibility_radius_max);
d231 3
a233 1
    // Determine an initial temperature that is based on sigma.
d235 9
a243 1
    Temperature T(999999);   // Accept all generated states.
d245 17
a261 4
    Statistics stats_utility =
        sa_metropolis_loop(S, utility, S_best, utility_best,
                           T.current(), (int) num_cycles_at_temp,
                           visibility_radius_max, dist_max);
d263 3
a265 1
    T = Temperature(k * stats_utility.standard_deviation());
d268 1
a268 1
    // Now anneal.
d270 77
a346 1
    do
d348 13
a360 3
        stats_utility = sa_metropolis_loop(S, utility, S_best, utility_best,
                           T.current(), (int) num_cycles_at_temp,
                           visibility_radius_max, dist_max);
a361 2
        time                += num_cycles_at_temp;
        num_cycles_at_temp  *= beta;
d363 14
a376 1
        if (T.current() == 0.0) break;
d378 2
a379 2
        T.next_huang(lambda, stats_utility);
    } while (time < time_max);
d381 2
a382 1
    S = S_best;
@


1.2
log
@moved State, Statistics, and Temperature to their own files
@
text
@d69 1
d119 1
a119 1
            (T > 0.0 && sa_rand_double() < exp(delta_utility / T)))
d174 1
a174 1
    printf("tim_max = %d\n", time_max);
@


1.1
log
@Initial revision
@
text
@a66 1
#include "sa.h"
d69 3
d73 1
a73 5
#define INT_MAX std::numeric_limits<int>::max()
#define INT_MIN std::numeric_limits<int>::min()


State::State(int n, int *ii, int *jj)
d75 1
a75 220
    num_viewpoints = n;

    for (int k = 0; k < num_viewpoints; ++k)
    {
        pi[k] = ii[k];
        pj[k] = jj[k];
    }
}


void State::print(const char *prefix)
{
    printf("%s ", prefix);

    for (int k = 0; k < num_viewpoints; ++k)
    {
        if (k > 0) printf(" ");
        printf("(%d,%d)", pi[k], pj[k]);
    }

    printf("\n");
}


double sa_rand_double()
{
    return 1.0 * rand() / RAND_MAX;
}


State sa_rand_next_state
(
    State       S,
    int         visibility_radius_max,
    int         dist_max,
    CVIS_WANG  *v
)
{
    // Move a random viewpoint up to dist_max pixels along each axis.
    // The Euclidian distance moved could be sqrt(2) * dist_max.
    int k   = (int) (sa_rand_double() * S.num_viewpoints);
    int di  = sa_rand_double() * dist_max * (sa_rand_double() < 0.5 ? -1 : 1);
    int dj  = sa_rand_double() * dist_max * (sa_rand_double() < 0.5 ? -1 : 1);

    S.pi[k] += di;
    S.pj[k] += dj;

    // Fix out-of-range
    if (S.pi[k] > v->i_max) S.pi[k] = v->i_max;
    if (S.pi[k] < v->i_min) S.pi[k] = v->i_min;
    if (S.pj[k] > v->j_max) S.pj[k] = v->j_max;
    if (S.pj[k] < v->j_min) S.pj[k] = v->j_min;

    // TODO
    // move cluster of node pairs which are separated
    // by 2 * visibility_radius_max + d

    // TODO
    // teleportation of a node

    return S;
}


//  Class:          Statistics
//
//  Description:    Compute and return several statistics for a sequence
//                  of integers:  standard devation, min, max, and largest
//                  absolute change.
//
//                  Rather than storing all of the values to compute the
//                  standard deviation, use the equations
//
//                      E[x]                = sum(x) / n
//                      E[x^2]              = sum(x^2) / n
//                      standard deviation  = sqrt(E[x^2] - (E[x])^2)
//
class Statistics
{
public:
    void clear();
    Statistics() {clear();}
    void summation(int x);
    double standard_deviation();
    int diff_max() {return _diff_max;}
    int x_max() {return _x_max;}
    int x_min() {return _x_min;}
    void print();
private:
    int         n;
    long long   sum_x;
    long long   sum_x2;
    int         _x_max;
    int         _x_min;
    int         _diff_max;
    int         x_previous;
};


void Statistics::clear()
{
    n       = 0;
    sum_x   = 0;
    sum_x2  = 0;
    _x_max   = INT_MIN;
    _x_min   = INT_MAX;
    _diff_max= INT_MIN;
}


void Statistics::summation(int x)
{
    ++n;
    sum_x  += x;
    sum_x2 += (long long) x * x;

    if (x > _x_max) _x_max = x;
    if (x < _x_min) _x_min = x;

    if (n > 1)
    {
        int diff_abs = x - x_previous;
        if (diff_abs < 0) diff_abs *= -1;
        if (diff_abs > _diff_max) _diff_max = diff_abs;
    }

    x_previous = x;
}


double Statistics::standard_deviation()
{
    long long E_x  = sum_x  / n;
    long long E_x2 = sum_x2 / n;
    double variance = E_x2 - (E_x * E_x);
    printf("n = %d, E_x = %lld, E_x2 = %lld, variance = %f\n",
           n, E_x, E_x2, variance);
    return sqrt(variance);
}


void Statistics::print()
{
    printf("n=%d, sum_x=%lld, sum_x2=%lld, x_max=%d, x_min=%d, diff_max=%d\n",
        n, sum_x, sum_x2, _x_max, _x_min, _diff_max);
}


//  Class:          Temperature
//
//  Description:    ...
//
class Temperature
{
public:
    Temperature(double T_initial)       {T = T_initial;}
    double current()                    {return T;}
    void next_simple(double alpha)      {T *= alpha;}
    void next_huang(double lambda, Statistics stats_utility);
private:
    double T;
};


//  Function:       next_huang()
//
//  Purpose:        Compute the next temperature step based on
//                  Huang, Romeo, and Sangiovanni-Vincentelli,
//                  "An Efficient General Cooling Schedule for
//                  Simulated Annealing", ICCAD-86.
//
//                  Normally, just update T based on lambda and sigma, but
//                  at some point, identify that it's time to freeze the
//                  system, and then set the temperature to 0.
//
//                  Freezing is identified by comparing the range of utility
//                  to its largest change.  If equal, then set T = 0.
//
//                  lambda <= 1.0 controls the rate of utility change.
//                                Try lambda = 0.7
//
//                  sigma is the measured standard deviation of utility.
//
void Temperature::next_huang(double lambda, Statistics stats_utility)
{
    stats_utility.print();

    // Do we meet the freezing condition from p. 383, section (D) of article?
    if (stats_utility.x_max() - stats_utility.x_min() ==
        stats_utility.diff_max())
    {
        T = 0.0;
    }
    else 
    {
        // Use the standard deviation of utility
        // to compute the temperature change.
        double sigma = stats_utility.standard_deviation();
        double T_next = T * exp(-lambda * T / sigma);

        // exp(-something / 0.0) == 0.0, but I don't know if
        // this is true in C++.  So force this result here.
        if (sigma == 0.0)
        {
            T = 0.0;
        }
        else
        {
            // No need to worry about special case.
            if (T_next < 0.5 * T)
            {
                // Prevent drastic decrease from flat annealing curve.
                T = 0.5 * T;
            }
            else
            {
                T = T_next;
            }
        }
    }
@
